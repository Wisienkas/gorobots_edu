/*
 * ChaoscontrAndPostProc.cpp
 *
 *  Created on: Aug 15, 2011
 *      Author: Ren Guanjiao
 */

#include "ChaoscontrAndPostproc.h"

//This function is to initialize parameters
ChaoscontrAndPostproc::ChaoscontrAndPostproc(int p1 = 4) {
  //difference values
  diff_n1_ = 0;
  diff_n2_ = 0;
  diffi_ = 0;
  
  //control inputs
  input1_ = 0;
  input2_ = 0;
  
  //----------------Global parameters-----------------------------
  //two neuron connection weights*****
  w11_ = -22.;
  w12_ = 5.9;
  w21_ = -6.6;
  //two neuron bias terms*****
  theta1_ = -3.4;
  theta2_ = 3.8;
  
  //arrays for two neuron network output
  data_ = new data_t[PERIODMAX + 1]; //(data_t*) calloc (periodmax_+1,sizeof(data_t));
  data_[0].o1 = 0;
  data_[0].o2 = 0;
  
  //learning rate
  lr_ = 0.05;
  
  //weight of the hystesis
  thetahys_[0] = -0.5;
  thetahys_[1] = -0.6;
  
  //set frequency
  Freq = 2;
  
  //hysteresis inputs
  input_hys1 = input_hys2 = 0.0;
  
  //hysteresis weight
  whys = 1.1;
  
  //initialize hysteresis
  ahys1 = ahys_old1 = 0;
  ahys2 = ahys_old2 = 0;
  
  //initialize hysteresis output
  output1 = 0;
  output2 = 0;
  
  //set inverse
  inverse_ = 1;
  
  //initialize period
  setPeriod(p1);
  
  //counter
  //n_= 0;
  
  //outputs
  //o1_=0;
  //o2_=0;
  
  //control factor
  //cl_ = 0;
  
  //learning = true;
  
  //period calculated in postprocessing part
  //percount = 0;
  
  //
  //normalize_ = Freq * period_ + 1;
  
  //initialize slope
  //slopeUP_ = (double) 2./normalize_;
  //slopeDOWN_ = (double) 2./((1-period_)*normalize_);
  
  //Save files
  chaosoutput.open("input_hys1.txt");

}

ChaoscontrAndPostproc::~ChaoscontrAndPostproc() {
  //Save files
  chaosoutput.close();
}

//This function is to generate the ChaosControl CPG Signal
void ChaoscontrAndPostproc::ChaosControl() {
  step();
  PostProcessing();
}

void ChaoscontrAndPostproc::step() {
  double d1, d2;
  d1 = d2 = 0;
  if (n_ == period_) {
    n_ = 0;
    diff_n1_ = data_[period_].o1 - data_[0].o1; //Output neuron1
    diff_n2_ = data_[period_].o2 - data_[0].o2; //Output neuron2
    diffi_ = diff_n1_ * diff_n1_ + diff_n2_ * diff_n2_;
    
    if (learning) {
      d1 = cl_ * diff_n1_ - diff_n1_;
      d2 = cl_ * diff_n2_ - diff_n2_;
      input1_ = w11_ * d1 + w12_ * d2;
      input2_ = w21_ * d1;
    }
    
    if (learning)
      cl_ += ((diffi_ * lr_) / period_);
    else
      cl_ -= (0.2 * cl_);
    
    if (!learning) {
      if (cl_ < 1e-6)
        learning = true;
    }
    
    oscistep(); //calculate the output
    
    data_[0].o1 = o1_; //a buffer for computering
    data_[0].o2 = o2_;
  } else {
    n_++;
    
    oscistep(); //calculate the output
    
    data_[n_].o1 = o1_;
    data_[n_].o2 = o2_;
  }

}

// calculate output values
void ChaoscontrAndPostproc::oscistep() {
  double activityO1 = w11_ * o1_ + w12_ * o2_ + theta1_ + input1_;
  double activityO2 = w21_ * o1_ + theta2_ + input2_;
  
  o1_ = sigmoid_(activityO1);
  o2_ = sigmoid_(activityO2);
  
  //After calculating the output, inputs must be reseted to zero
  input1_ = input2_ = 0;
}

//This function is to post-process the signals of the CPG generated by Chaos Control part 
void ChaoscontrAndPostproc::PostProcessing() {
  if (0 == (++percount % (normalize_))) //time window funciton
      {
    input_hys1 = FAC * (data_[n_].o1 + thetahys_[0]);
    input_hys2 = FAC * (data_[n_].o2 + thetahys_[1]);
  } else {
    input_hys1 = 0;
    input_hys2 = 0;
  }
  chaosoutput<<input_hys1<<"  "<<input_hys2<<endl;
  //----------------------------------------------------------------
  //-----------------This is for the first neuron-------------------
  //----------------------------------------------------------------
  ahys_old1 = ahys1;
  ahys1 = tanh_(whys * ahys1 + input_hys1); //hysteresis unit
      
  //signal integrator
  if (fabs(ahys1 - ahys_old1) > EPSILON) {
    if (ahys1 > 0)
      output1 = -inverse_;
    else
      output1 = inverse_;
  }
  
  if ((inverse_ * ahys1) > 0) {
    output1 += slopeUP_;
  } else {
    output1 += slopeDOWN_;
  }
  
  //fix it -1 to 1
  if (output1 > 1.) {
    output1 = 1.;
  } else if (output1 < -1.) {
    output1 = -1.;
  }
  
  //----------------------------------------------------------------
  //---------------This is for the second neuron--------------------
  //----------------------------------------------------------------
  ahys_old2 = ahys2;
  ahys2 = tanh_(whys * ahys2 + input_hys2); //hysteresis unit
      
  //signal integrator
  if (fabs(ahys2 - ahys_old2) > EPSILON) {
    if (ahys2 > 0)
      output2 = inverse_;
    else
      output2 = -inverse_;
  }
  
  if ((-inverse_) * ahys2 > 0) {
    output2 += slopeUP_;
  } else {
    output2 += slopeDOWN_;
  }
  
  //fix it -1 to 1
  if (output2 > 1.)
    output2 = 1.;
  else if (output2 < -1.)
    output2 = -1.;
  
}

//This function is to reset the parameters of ChaosControl CPG signal
void ChaoscontrAndPostproc::reset() {
  percount = 0;
  cl_ = 0;
  n_ = 0;
  data_[0].o1 = o1_ = 0;
  data_[0].o2 = o2_ = 0;
  learning = true;
  normalize_ = Freq * period_ + 1;
  slopeUP_ = 2. / normalize_;
  slopeDOWN_ = 2. / ((1 - period_) * normalize_);
  
}

